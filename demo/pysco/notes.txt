------------------------------------------------------------------------

:set expandtab
:retab

Remove trailing whitespace
:%s=\s\+$==

------------------------------------------------------------------------


class Foo (Instr):
    super(Foo, self).__init__():
        pass




lfo = LFO(4)




------------------------------------------------------------------------
Slipmat class
	centralized object for managing score and time

------------------------------------------------------------------------

Lesson in the help.

------------------------------------------------------------------------

How do the internals of a sine wavework? How are its mechanisms graphed?

Need to think of opcodes as part of a more low-level system.

Think ByteCode?

------------------------------------------------------------------------

Smart graphs. Nodes that seek out data and commands from within a graph.

Example. When a unit generator is graphed to a network of other unit generators, it traverses the list seeking pertinent information on how it should behave. The sample rate and control rate could be part of this data.

------------------------------------------------------------------------

a1 sine amp, frequency, phase_offset

@  [  ]      @          @
a1 sine amp, frequency, phase_offset
   @

-----------------------------------------------

bind('convert_midi', {'i', 1, 5}, midi_to_freq)

score('''
i 1 0 5 0.707 72
i 1 + . .     62
i 1 + . .     63
i 1 + . .     65
i 1 + . .     67
i 1 + . .     68
i 1 + . .     70
''')

The pmap() exists to postprocess or preprocess,
depending if you are looking at this from the
perspective of the slipmat score of the
traditional Csound score.

The bind(), if that really is its name, creates
and graphs a callback onto a selected list of
Csound pfields.

The processing happens as the score is written
in pieces.

-------------------------------------------------------

score('i 1 0 5 0.707 72')
disable_bind('name', False)  # Disables it
enable_bind('name', True)   # Enables it

bind('name', selection, some_func, *args, enabled=True)
score('i 1 0 5 0.707 72')
disable_bind('name', False)  # Disables it
enable_bind('name', True)   # Enables it

score.bind('name', selection, some_func, *args)
score('i 1 0 5 0.707 72')
score.set_bind('name', False)  # Disables it
score.set_bind('name', True)   # Enables it

score.bind_callback('name', selection, some_func, *args)
score('i 1 0 5 0.707 72')
score.set_callback('name', False)  # Disables it
score.set_callback('name', True)  # Enables it

with t(0):
with time(0):
with when(0):
with start(0):

with time(0):
	score('FOO')

	with t(4):
		score('BAR')

	score.process(SOMETHING)

score.process(SOMETHING

-------------------------

simple_sine = instr('''
	idur = p3
	iamp = p4
	ifreq = p5

	l1 line iamp, idur, 0
	a1 oscils l1, ifreq, 1

	@audio_out a1
''')


@audio_out(a1) becomes
chnset FOO, a1

gets added to audio_clear_stack, which is cleared at end of chain



define ALL the graphing patterns!!!




-------------------------


<INDENT>@<TIME>: <FOO>


On <INDENT>
	is_time_stacking = true


if time_stacking = true
	# Do nothing, bascially
	if blank line:
		exec_block.append()

	# Exit time queue as indent is back at base
	elif indent_stack = line.indent:
		is_time_stacking = false

	# Add to stack
	elif indent_stack > indent_stack:
		indent_stack.append
		
		if @:
			if <INDENT>@<WHEN>:<WHAT>:
				process single line
				#include indent_stack[0]

		elif  <INDENT>@<WHEN>:
			time_stack.append(<WHEN>)
			indent_stack.append(line.indent)

	# Continue pushing current block
	elif indent_stack == line.indent:
		(use indent_stack[0])
		exec_block.append()

	elif indent_stack < line.indent:
		do:
			index.pop()
		until indent_pop == line.indent

if not time_stacking
	if @:
		if <INDENT>@<WHEN>:<WHAT>:
			process single line

		else <INDENT>@<WHEN>:
			is_time_stacking = true
			time_stack.append(<WHEN>)
			indent_stack.append(line.indent)

	else
		exec_block.append()






-------------------------
@<FOO>: <BAR>

time_stack.append(<FOO>)
<BAR>
time_stack.pop()


@<FOO>:
	@<FOO_2>: <BAR>

time_stack.append(<FOO>)
time_stack.append(<FOO_2>)
<BAR>
time_stack.pop()
time_stack.pop()


-------------------------
From
http://codehop.com/nine-rules-for-scheduling-events/

1. Individual Events

@0 foo()
@1 foo()
@2 foo()
@3 foo()
2. List

@[0, 1, 2, 3] foo()
3. Identifier

t = [0, 1, 2, 3]
@t foo()
4. List Comprehension

@[i for i in range(0, 4)] foo()
5. Loop

for i in range(0, 4):
    @i foo()
6. Function

def bar():
    @0 foo()
    @1 foo()
    @2 foo()
    @3 foo()

bar()
7. Nested

foo()
1:
    foo()
    1:
        foo()
        1:
            foo()
8. Item Iteration

items = (0, 1, 2, 3)
@[i for i in items] foo()
9. Map

def bar(x): return x
@(map(bar, range(0, 4)) foo()
