################################
Evolving Amen - A Pycso Tutorial
################################


Set up Sampler Instrument
Classical Score example with 1 bar repeat 4 times
score() version
split bars with cue()
Python def
def measure()
instrs as definitions
    factoring out instr number, start time, duration
    default values
    One orchestra instrument becomes many score instruments
Refactor instrs
    Importing choice from Python Library
    Choice
    Lists
Score phrase to def phrase()
Algorithmic flair def
    Lists

Arranging


Where to put p_callback and pmap
    dB for p_callback
    slight variations to pan position / pitch for pmap


* Keep your instr interfaces as generic as possible, fashion specifics in the score.
    # bad
    ipch = cpspch(p5)

    # good
    ifreq = p5

    cpspch(freq)


Easy Point of Entry
===================

Don't know Python, but know the Csound score. Everything, and I mean
everything, you already know about the score can be used in Pysco,
without modification, as long as it's wrapped in the score() function.

..
    .. literalinclude:: ../../demo/pysco/test.csd 


.. code-block:: python

    <CsScore bin="python pysco">

    score('''
    f 1 0 8192 10 1
    t 0 189

    i 1 0 0.5 0.707 9.02
    i 1 + .   .     8.07
    i 1 + .   .     8.09
    i 1 + .   .     8.11
    i 1 + .   .     9.00
    i 1 + .   .     8.09
    i 1 + .   .     8.11
    i 1 + .   .     8.07
    ''')

    </CsScore>

Code:
https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test.csd

Toot 2 - Pfield Processing
--------------------------

The original idea of Pysco came from a user request in the list in
which someone wanted to be able to use an alternative way of
expressing notes in the form of C5, D#4, G4, etc. The following
example does just that using the pfield mapper function pmap(). This
is a post-processor that goes through score data and changes it based
on the function passed to pmap.

.. code-block:: python

    score('''
    f 1 0 8192 10 1
    t 0 120

    i 1 0 0.5 -3 D5
    i 1 + .   .  G4
    i 1 + .   .  A4
    i 1 + .   .  B4
    i 1 + .   .  C5
    i 1 + .   .  A4
    i 1 + .   .  B4
    i 1 + .   .  G5
    ''')

    pmap('i', 1, 4, dB)
    pmap('i', 1, 5, conv_to_hz)

Code:
https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test2.csd

You may have noticed that it also translates decibels with pfield.

Time with the cue() object
--------------------------

Time is treated like other control structures, akin to the if
statement. The cue() object translates the current postion of time in
the score, and modifies pfield 2 to reflect the position. For example,
the follow two events start at beat 0 and beat 1.5

.. code-block:: python

    score('''
    i 1 0   0.5 0.707 8.00
    i 1 1.5 0.5 0.707 9.00
    ''')

Using the same two unmodified events combined with the statement "with
cue(100):", it plays these two events at beat 100 and beat 101.5:

.. code-block:: python

    with cue(100):
        score('''
        i 1 0   0.5 0.707 8.00
        i 1 1.5 0.5 0.707 9.00
        ''')

That is:
100 + 0 = 100
100 + 1.5 = 101.5

These cues also nest, and these two notes play on beats 103 and 104.5.

.. code-block:: python

    with cue(100):
        with cue(3):
            score('''
            i 1 0   0.5 0.707 8.00
            i 1 1.5 0.5 0.707 9.00
            ''')

That is:
100 + 3 + 0 = 103
100 + 3 + 1.5 = 104.5

Here's a code example that cues each measure independently, so that
the start times for each i-event block is normalized to zero. Crazy
easy to manage events in time this way:

https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test10.csd

Don't like Time-In-Beats? How about Measures instead
----------------------------------------------------

So you're writing a piece in 4/4 and you'd rather organize events in
measures instead of beats because it totally makes more sense to do it that way. Here's how to customize the cue() with a Python function:

.. code-block:: python

    def measure(t):
        return cue((t - 1) * 4.0)

Now let's place those two notes into measure 16.

.. code-block:: python

    with measure(16):
        score('''
        i 1 0   0.5 0.707 8.00
        i 1 1.5 0.5 0.707 9.00
        ''')

That that math works out to:

(16 - 1) * 4) + 0 = 60

(16 - 1) * 4) + 1.5 = 61.5

Gone are the days of manually keeping track of absolute position in
beats, or even seconds, for each note.

Similiar code to example 3, but uses the custom measure():
https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test11.csd

This is measure() example is a simple conversion, but it wouldn't take much to create a custom object that allowed users to mix and match time signatures.

Functions as Reusable Musical Phrases
-------------------------------------

Let's wrap up those two notes into a re-usable phrase.

.. code-block:: python

    def my_phrase():
        score('''
        i 1 0   0.5 0.707 8.00
        i 1 1.5 0.5 0.707 9.00
        ''')

And let's place them in the first four measure of the score:

.. code-block:: python

    with measure(1): my_phrase()
    with measure(2): my_phrase()
    with measure(3): my_phrase()
    with measure(4): my_phrase()

Alternatives to Score() i_events
--------------------------------

The score() isn't the only way to create i-events. Here is an
alternative form using event_i()

.. code-block:: python

    def my_phrase():
        event_i(1, 0, 0.5, 0.707, 8.00)
        event_i(1, 1.5, 0.5, 0.707, 9.00)

The advantage is that you can inline Python functions directly into i-events:

.. code-block:: python

    event_i(1, 0, random(), random(), cpspch(8.00))

p_callback(), And Alternative to pmap()
---------------------------------------

The pmap() is a processor, and processes data that is already inside
the score() object. The p_callback() modifies events as they're being
inserted. In this example, the data stored for pfield 5 is the
frequency, not the written string representation, once inserted into
the score.

.. code-block:: python

    p_callback('i', 1, 5, conv_to_hz)

    event_i(1, 0, 4, 0.707, 'C4')

Related code:
https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test12.csd

cue() and p_callback() work as a team
-------------------------------------

Remember our two note phrase:

.. code-block:: python

    def my_phrase():
        event_i(1, 0, 0.5, 0.707, 8.00)
        event_i(2, 1.5, 0.5, 0.707, 9.00)

Let's say we wanted to play it as is in measure 1, but wanted to
transpose it 1 octave lower in measure 2, and as back to normal in
measure 3. Any p_callback() placed within the context of a "with
cue()" statement, only exists for that block, disappearing once that
block is finished.

.. code-block:: python

    p_callback('i', 1, 5, cpspch)  # Pfield 5 will be stored as Hz in the score()

    with measure(1):
        my_phrase()

    # Plays 1 octave lower
    with measure(2):
        p_callback('i', 1, 5, lambda x: x / 2.0)  # p5 will be divided by 2
        my_phrase()

    # Back to normal
    with measure(3):
        my_phrase()

Code example that illustrates this:
https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/test16.csd

